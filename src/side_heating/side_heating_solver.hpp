#pragma once
#include <QtCore/QMutex>
#include <QtCore/QThread>

//! Класс, отвечающий за решение конвективной задачи бокового подогрева.
class SideHeatingSolver : public QThread
{
    Q_OBJECT

public:
    //! \param[in] parent Указатель на родительский виджет.
    SideHeatingSolver(QObject *parent = NULL);

    ~SideHeatingSolver();

    /*!
     *  \brief Функция для задания физических параметров задачи.
     *  \param height           Высота расчетной области.
     *  \param Pr               Число Прандтля.
     *  \param Gr               Число Грасгофа.
     *  \param isLeftWallHard   Флаг, показывающий является ли левая стенка жесткой.
     *  \param isRightWallHard  Флаг, показывающий является ли правая стенка жесткой.
     *  \param isTopWallHard    Флаг, показывающий является ли верхняя стенка жесткой.
     *  \param isBottomWallHard Флаг, показывающий является ли нижняя стенка жесткой.
     */
    void setProblemParameters(double height, double Pr, double Gr, bool isLeftWallHard,
                              bool isRightWallHard, bool isTopWallHard, bool isBottomWallHard);

    /*!
     *  \brief Функция для задания математических параметров задачи.
     *  \param nx           Число узлов сетки по горизонтали.
     *  \param ny           Число узлов сетки по вертикали.
     *  \param numOfMaxIter Максимальное число итераций.
     *  \param wT           Коэффициент релаксации для температуры.
     *  \param wPsi         Коэффициент релаксации для функции тока.
     *  \param wOmega       Коэффициент релаксации для вихря.
     */
    void setSolverParameters(int nx, int ny, int maxNumOfIter, double wT, double wPsi, double wOmega);

    //! \return Значение по умолчанию для параметра релаксации температуры.
    double getDefaultWT();

    //! \return Значение по умолчанию для параметра релаксации функции тока.
    double getDefaultWPsi();

    //! \return Значение по умолчанию для параметра релаксации вихря.
    double getDefaultWOmega();

    //! \return Значение по умолчанию для максимального числа итераций.
    int getDefaultMaxNumOfIter();

    //! Прервать работу решателя.
    void cutOffSolution();

protected:
    //! Запуск решателя в отдельном потоке.
    void run();

signals:
    /*!
     *  Сигнал о завершении очередной итерации решателя.
     *  \param currentIteration     Номер завершенной итерации.
     *  \param maxNumOfIterations   Максимально допустимое число итераций.
     *  \param currentResidual      Текущая невязка по нелинейности.
     */
    void iterationFinished(int currentIteration, int maxNumOfIterations ,double currentResidual);

    /*!
     *  Сигнал о том, что решение прервано из-за того, что достигнуто максимальное число итераций.
     *  \param currentResidual      Текущая невязка по нелинейности.
     */
    void maxIterNumberAttained(double currentResidual);

    //! Сигнал о завершении работы решателя.
    void solutionFinished();

private:
    /*!
     *  Функция выделяет динамическую память для данных, создает конечноэлементную сетку,
     *  а также задает начальное приближение для искомых функций T, Psi и Omega.
     */
    void prepareData();

    //! Сборка СЛАУ для температуры.
    void tSLAE();

    //! Сборка СЛАУ для температуры.
    void psiSLAE();

    //! Сборка СЛАУ для температуры.
    void omegaSLAE();

    //! Вычисление вектора скорости.
    void formV();

    //! Вывод результатов.
    void output();

    //! Освобождение динамически выделенной памяти.
    void freeMemory();

    //! Расчет невязки по нелинейности с учетом коэффициента релаксации.
    double residual();

    //! Очистка матрицы СЛАУ и вектора правой части(заполнение их нулями).
    void clearSLAE();



    //********************************************************************************************************
    //Физические и геометрические параметры задачи.
    //********************************************************************************************************
    double Pr;      //!< Число Прандтля.
    double Gr;      //!< Число Грасгофа.
    double width;   //!< Ширина расчетной области.
    double height;  //!< Высота расчетной области.

    //********************************************************************************************************
    //Математические параметры задачи.
    //********************************************************************************************************
    double wT;          //!< Коэффициент релаксации для температуры.
    double wPsi;        //!< Коэффициент релаксации для функции тока.
    double wOmega;      //!< Коэффициент релаксации для вихря.
    int maxNumOfIter;   //!< Максимальное число итераций решателя.

    //********************************************************************************************************
    //Переменные, описывающие краевые условия задачи.
    //********************************************************************************************************
    bool isLeftWallHard;    //!< Флаг, показывающий является ли левая стенка жесткой.
    bool isRightWallHard;   //!< Флаг, показывающий является ли правая стенка жесткой.
    bool isTopWallHard;     //!< Флаг, показывающий является ли верхняя стенка жесткой.
    bool isBottomWallHard;  //!< Флаг, показывающий является ли нижняя стенка жесткой.

    //********************************************************************************************************
    //Конечноэлементная сетка. Сетка является регулярной. Расчетная область разбивается на прямоугольники с
    //длинной сторон hx и hy. Число прямоугольников в вертикальном и горизонтальном напрвлениях составляе
    //nx - 1 и ny - 1 соответственно.
    //********************************************************************************************************
    int nx;     //!< Число узлов в сетке по горизоньали
    int ny;     //!< Число узлов в сетке по вертикали
    double hx;  //!< Шаг сетки по горизонтали
    double hy;  //!< Шаг сетки по вертикали

    int **nvtr;
    double **xy;
    int numOfPoints;
    int numOfTriangles;

    //********************************************************************************************************
    //Информация о краевых условиях. Для температуры - это узлы в которых задано первое КУ и значение
    //температуры в этих узлах. Для функции тока и для вихря - только узлы. Для функции тока значение
    //на границе всегда равно 0, а для вихря оно зависит от текущего значения функции тока.
    //********************************************************************************************************
    int *topT_bc1;
    int *topPsiOmega_bc1;

    double *T_bc1;

    int numOfPointsT_bc1;
    int numOfPointsPsiOmega_bc1;

    //********************************************************************************************************
    //СЛАУ и вектора неизвестных (в том числе их копии с предыдущей итерации по нелинейности).
    //********************************************************************************************************
    int *ig;
    int *jg;
    double *ggl;
    double *di;
    double *ggu;
    double *f;

    double *t;
    double *psi;
    double *omega;

    double *tOld;
    double *psiOld;
    double *omegaOld;

    //********************************************************************************************************
    //Вектора компонент скорости и радиального градиента температуры.
    //********************************************************************************************************
    double *tx;
    double *vx;
    double *vy;

    //********************************************************************************************************
    //********************************************************************************************************
    QMutex mutex;   //!< Mutex обеспечивает защиту переменной от одновременного доступа из нескольких потоков.

    bool isSolutionCutOff;   //!< Флаг, реагирующий на сигналы извне о прерывании работы решателя.
};
